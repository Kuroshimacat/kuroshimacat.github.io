{"posts":[{"title":"FullTClash开发文档","text":"本文为FullTClash的开发者文档，基于3.5.1-dev (034837a)版本进行编写，与目前版本可能有出入 说明&amp;免责声明本文不是FullTClash的流媒体检测开发文档，而更倾向于FullTClash本体的开发，本文不会对函数、变量等做过多说明。 本文作者不持有FullTClash大部分源码版权，本文作者亦无对使用或阅读本文进行操作导致结果负责的义务，使用此文档为读者个人行为。作者对一切使用本文档导致的、阅读此文档导致的一切后果不承担任何责任，同时本文作者禁止一切对本文越权的行为，并不支持任何使用本文内容进行破坏的行为。如不同意，请勿继续阅读本文，使用或阅读本文即代表您同意以上内容。 变量__version__：为FullTClash的版本号，在FullTclash\\libs\\export.py中，会影响/version命令。 custom_source：用于确定绘图的emoji样式，在FullTclash\\libs\\export.py中。 group：有0、1、2三个值，分别对应全部用户、User组以上用户、Admin组用户，可用于功能的权限设定。 admin = init_bot.admin：为管理员变量，赋值有多种形式（多处），默认已经赋值，建议不要修改，作为只读变量使用。 task_num：任务数，建议在执行任务时对其+1以防止任务冲突。 password：订阅密码。 latest_version_hash：远程哈希值。 USER_TARGET = config.getuser() ：用户列表，已赋值，建议只读。 函数logger.info()：输出一般日志。 logger.warning()：输出警告日志。 logger.error()：输出警告日志。 @app.on_message()：通常用作命令识别中，通常会导入filters.command()和group使用。 filters.command()：可以为字典，确定命令为何时开始执行功能，用于功能函数中。 testurl(_, message: Message, **kwargs)：从订阅链接测试流媒体解锁。 test(_, message: Message, **kwargs)：从已有订阅测试流媒体解锁。 analyzeurl(_, message: Message, test_type=&quot;all&quot;, **kwargs)：从订阅链接进行拓扑测试。 analyze(_, message: Message, test_type=&quot;all&quot;)：从已有订阅进行拓扑测试。 speedurl(_, message: Message, **kwargs)：从订阅链接进行测速。 speed(_, message: Message)：从已有订阅进行测速。 domain_to_ip(host: str)：域名转IP。 batch_domain2ip(host: list)：批量转换域名到IP。 geturl(string: str)：获取订阅链接。 getSubInfo(_, message)：获取订阅信息。 getsub_async(url: str, username: str, pwd: str, proxy=None)：通过邮箱获取订阅，目前仅支持无邮箱验证的v2board。 get_airport_info(text: str = None)：获取机场信息 get(self, key, _default=None)：获取信息。 get_org(self)：获取组织信息。 get_ip(self)：获取IP信息。 get_country_code(self)：获取国家代码。 get_city(self)：获取城市。 get_asn(self)：获取ASN信息。 class ExportResult：注意，这是类，放在此为了以下绘图内容的浏览方便，为实现通用的绘图。 class ExportTopo(ExportResult)：注意，这是类，放在此为了以下绘图内容的浏览方便，为实现拓扑的绘图。 class ExportSpeed(ExportResult)：注意，这是类，放在此为了以下绘图内容的浏览方便，为实现测速的绘图。 key_value(self)：得到测试项大小 interval(self)：去重排序。 colorvalue(self)：绘图选色。 exportImage(self)：输出绘图。 建议翻阅lib\\export.py以更充分的了解绘图的开发 bot_task_queue(client: Client, message, task_type: str, qu: asyncio.Queue, **kwargs)：任务队列函数。 dynamic_data_filter(data)：过滤器函数。 my_filter(queue)：废弃的函数，与过滤器可能有关。 init_button()：按钮，可参阅流媒体脚本中的写法使用。 check_init()：检测是否为第一次运行。 debug_interface(_, message)：开发工具，被用在/map指令上。 reloadUser()：重载User列表。","link":"/2023/02/21/FullTClashDev/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/12/19/hello-world/"},{"title":"2take1menu的Lua脚本编写","text":"本文介绍2take1menu的脚本制作方法 免责声明本文作者不支持任何游戏中作弊行为，本文所介绍的方法仅能作为技术介绍，不得将本文所介绍的方法用于脚本出售/租赁等非法商业行为，同时，本文作者不对由本文方法造成的问题（包括封禁/财产损失等）负任何责任。 什么是Lua？ Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description. 这是Lua官网上对Lua的描述，简言之：这是一种脚本语言，功能很多，很强大。 安装Lua对于Windows、Linux、macOS都有对应的安装方式 Windows对于Windows，我更建议直接下载安装包进行使用，访问Lua 二进制文件下载 ，下载Windows对应的二进制文件，目录应该是这样的： 12345. lua54.dll lua54.exe luac54.exe wlua54.exe 如果你愿意，可以删去这些文件名中的54，这代表它是Lua5.4版本，在下面的命令中，我将使用删去54的命令，以使各操作系统的命令大致统一。 随后，你应该将解压缩的文件夹添加进path中，然后实验一下： 1PS C:\\&gt; lua #cmd也不是不行 如果出现这个，就代表你成功了： 12Lua 5.4.2 Copyright (C) 1994-2020 Lua.org, PUC-Rio&gt; 随后试试输入进： 1print(&quot;hello world!&quot;) 它应该会返回hello world!，如果你在其中任何一个步骤出错了，都可能导致失败，那么请从头再试。 Linux对于Linux，最推荐的方法是使用包管理器，例如，对于Ubuntu/Debian，可以尝试： 1sudo apt install lua5.4 不同的发行版有不同的包管理器，如果你使用LFS，可能还需要处理更多问题，请自行谷歌解决。 macOS对于macOS，同样推荐用包管理器解决，一个比较好的方法是使用brew进行安装，brew的安装可以在他们的官方网站上找到，国内用户最好换成清华源等国内源 安装指令可能是： 1brew install lua 根据实际情况自己调整。 编辑器的选择VSCode是我的选择，如果你喜欢别的，尽管用吧，Lua并不是很需要集成环境，因此能写就行。 开始首先，你要熟悉Lua的语法，因为比较简单，请自行上网学习，2t脚本并不需要你掌握全部的Lua知识，只需要掌握基本的写法即可 了解2take1的脚本这有几个重要的网址： 2take1的脚本介绍 2take1的API文档 你应该已经了解什么是API了吧？ 阅读打开脚本介绍，你需要通篇阅读他们以基本的了解2take1的脚本使用方式，这可以加强你脚本的写作能力 API文档不需要通篇阅读，我们需要什么就看什么 Example一个基本的Lua脚本的制作流程大概是： 明确功能 开始CV 测试可用性 封装成luac格式防止源码泄露 那么，我们先要明白一些写法，我会带你完成第一个测试脚本 我们想做一个没用的脚本，并且希望有一个选项卡，里面套一个选项卡，于是我们阅读API文档，在文档中看见了： 1Feat add_feature(string name, string type, integer|nil parent, function|nil script_handler) 什么意思？？？？？ 拆分看，整个一行分两部分，Feat和后面的一大堆，后面的明显是函数，前面的是描述，那么看看函数部分： 1add_feature(string name, string type, integer|nil parent, function|nil script_handler) 其实很易懂，翻译一下就明白了，但string type在哪里？翻到文档开头，有个表格： Name Description parent Parent feature toggle Toggle feature action Action feature value_i Toggle feature with integer value value_f Toggle feature with float value slider Toggle feature with slider value_str Toggle feature with string values action_value_i Action feature with integer value action_value_f Action feature with float value action_slider Action feature with slider action_value_str Action feature with string values autoaction_value_i Auto Action feature with integer value autoaction_value_f Auto Action feature with float value autoaction_slider Auto Action feature with slider autoaction_value_str Auto Action feature with string values 现在一切都一目了然了，我们需要一个父选项卡，那么string type自然是parent，那么整理一下代码，删去我们不需要的元素，就可以得到： 1a=menu.add_feature(&quot;start&quot;,'parent',0,function()end) 这里为什么要加入a=呢，因为我们待会还要用到这个父选项卡，然后往里面丢东西。 解释一下吧，start是父选项卡的名字，会显示在选项卡上，parent是我们刚刚解释的string type，0代表它的id，空的function代表他不会执行任何代码（实际上就意味着只是个选项卡，而不是实际的命令按钮） 现在选项卡有了，我们想在里面再加一个选项卡，就像这样： 1b=menu.add_feature(&quot;我在里面&quot;,'parent',a.id,function()end) 这里和a很像，除了名字，唯一不同的就是id变成了a.id（这也是我们为什么在前面用a=的原因，这意味着它属于a，在游戏里会显示在a的内部，也就是说，你在游戏里要先点击start这个选项卡，才能点击我在里面这个选项卡。 现在我们有了选项卡，如何添加一个命令呢？查阅string type，命令的种类很多，这里因为是教程，我们选择最简单也最常见的action。 1menu.add_feature('action1','action',b.id,function()end) 现在命令按钮action1出现在选项卡我在里面里了，让我们给他添加一些指令吧： 123menu.add_feature('action1','action',b.id,function() menu.notify(&quot;成功启动&quot;, &quot;成功&quot;, 3, 0xff7b68ee)end) 我们把end)拆下去，做成缩进来方便阅读和编写，当然，这里也可以加入多行命令。 这里解释一下里面的命令，这回弹出一个窗口，就像是你每次游戏启动的一样，你可以在API文档里找到用法，这里只简单解释一下后面的0xff7b68ee，把他拆成0xff和7b68ee，前面是透明度，后面是十六进制颜色，有趣吧 : ) 这样，我们的第一个简单的lua脚本就写完了，它没什么功能，但是里面的方法是在更高级的脚本中能发现的，也是绝大多数脚本的基础，现在，扔到%appdata%\\PopstarDevs\\2Take1Menu\\scripts\\里面尝试一下，如果能用，那么请继续 我们写脚本，即便是免费脚本，也不是很希望别人看到源码，在2take1的市场中，很多人盗用别人发布的免费脚本制成付费的脚本，这种行为是我们不想看到的，于是，我们把脚本进行编译，在命令行中执行： 1luac54 -s GTA.lua #GTA.lua是你的脚本名字，根据需求更改 -s可以删去调试信息，防止反编译，建议使用上，但即便已经编译，也不代表绝对安全。 输出一个luac.out，把它改名为GTA.lua以让2take1明白这是脚本（luac后缀可能也行，但我没试过） 写道这里是1972个词，我们总算是完成第一个2take1脚本了，现在喝口水休息一下吧 : ) 如果你在过程中遇到问题，请在评论区留言，我看到会及时回复的 API文档翻译和解释（正在制作的计划，太难了，先鸽）（在做了在做了） 后记这么长的文章可是花了我一个多小时完成的（不包括API文档翻译和解释），还不快快转发？（恼 谢谢你看完，如果你有任何问题，请及时去评论区告诉我。 : )","link":"/2022/12/20/2take1/"},{"title":"树莓派pico的简单食用方法","text":"树莓派pico，官网标价四美元，极其有冲击力的微控制器，本文会描述pico的简单使用方法 拆封pico装在类似于糖果的袋子里，拆开就行 连接你需要准备一些东西： pico（这不废话吗） 一台带有usb接口的电脑 可以连接pico的usb线 Thonny（一款软件IDE，支持pico和自动安装micropython） 随后将pico轻轻的（确信）连接到pc上，轻按BootSel，你会看到一个“驱动器”连接，点击里面的网页文件，去下载micropico的文件，pico会自动重启进入micropython模式 当然，如果你不喜欢这样安装，也可以在Thonny中自动安装 开始编写打开Thonny，你大概会看到： 这时注意右下角，还是本地python，点击一下，切换到pico： 这样主界面会变成： 简单介绍，最大的区域是主编辑区，底部的shell是执行命令的地方，和绝大多数IDE类似 拜拜 : )","link":"/2022/12/20/pico/"}],"tags":[{"name":"FullTClash","slug":"FullTClash","link":"/tags/FullTClash/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Dev","slug":"Dev","link":"/tags/Dev/"},{"name":"lua","slug":"lua","link":"/tags/lua/"},{"name":"2take1","slug":"2take1","link":"/tags/2take1/"},{"name":"pico","slug":"pico","link":"/tags/pico/"},{"name":"micropython","slug":"micropython","link":"/tags/micropython/"}],"categories":[],"pages":[]}